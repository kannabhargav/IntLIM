% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/07_LearnGraphPredictionModel.R
\name{CreatePoolingFilterKMeans}
\alias{CreatePoolingFilterKMeans}
\title{#' Create the graph pooling filter, given the adjacency matrix of the input graph.
#' @param modelInputs An object of type "ModelInputs".
#' @param k The output dimensionality of the filter.
#' @param poolType One of "mean", "median", "max", or "min".
#' @export
CreatePoolingFilter <- function(modelInputs, k, poolType){
  
  # Perform hierarchical clustering.
  hier <- doHierarchicalClustering(modelInputs)
  clusters_as_sets <- initializeClusters(hier)
  hier <- initializeMergeDataFrame(hier)
 
  # Find the clusters.
  clusters <- findKClusters(modelInputs=modelInputs, clusters=clusters_as_sets,
                           hClustResults=hier, k=k, allClusters={}, allVariances = {})
  cluster_names <- sort(names(clusters))
  
  # Arrange cluster mappings in matrix.
  mappings <- matrix(0, ncol = k, nrow = length(igraph::V(g)))
  cluster_length <- matrix(0, length(unique(clusters)))
  for(i in 1:length(cluster_names)){
    which_in_cluster <- which(rownames(modelInputs@line.graph) %in% 
                                unlist(clusters[[cluster_names[i]]]))
    mappings[which_in_cluster, i] <- 1
    cluster_length[i] <- length(which_in_cluster)
  }
  
  # Return pooling filter.
  newPoolingFilter <- methods::new("PoolingFilter", filter=mappings, filter.type=poolType,
                                   cluster.sizes=cluster_length, individual.filters=list())
  return(newPoolingFilter)
}
Create the graph pooling filter, given the adjacency matrix of the input graph.}
\usage{
CreatePoolingFilterKMeans(modelInputs, k, poolType)
}
\arguments{
\item{modelInputs}{An object of type "ModelInputs".}

\item{k}{The output dimensionality of the filter.}

\item{poolType}{One of "mean", "median", "max", or "min".}
}
\description{
#' Create the graph pooling filter, given the adjacency matrix of the input graph.
#' @param modelInputs An object of type "ModelInputs".
#' @param k The output dimensionality of the filter.
#' @param poolType One of "mean", "median", "max", or "min".
#' @export
CreatePoolingFilter <- function(modelInputs, k, poolType){
  
  # Perform hierarchical clustering.
  hier <- doHierarchicalClustering(modelInputs)
  clusters_as_sets <- initializeClusters(hier)
  hier <- initializeMergeDataFrame(hier)
 
  # Find the clusters.
  clusters <- findKClusters(modelInputs=modelInputs, clusters=clusters_as_sets,
                           hClustResults=hier, k=k, allClusters={}, allVariances = {})
  cluster_names <- sort(names(clusters))
  
  # Arrange cluster mappings in matrix.
  mappings <- matrix(0, ncol = k, nrow = length(igraph::V(g)))
  cluster_length <- matrix(0, length(unique(clusters)))
  for(i in 1:length(cluster_names)){
    which_in_cluster <- which(rownames(modelInputs@line.graph) %in% 
                                unlist(clusters[[cluster_names[i]]]))
    mappings[which_in_cluster, i] <- 1
    cluster_length[i] <- length(which_in_cluster)
  }
  
  # Return pooling filter.
  newPoolingFilter <- methods::new("PoolingFilter", filter=mappings, filter.type=poolType,
                                   cluster.sizes=cluster_length, individual.filters=list())
  return(newPoolingFilter)
}
Create the graph pooling filter, given the adjacency matrix of the input graph.
}
