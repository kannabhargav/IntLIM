#' Construct a co-regulation graph where nodes are genes and metabolites, and edges
#' are present between nodes and edges that meet the processing cutoffs. Note that
#' the ProcessResults function must be run before BuildCoRegulationGraph is run.
#' This is because the BuildCoRegulationGraph uses the output from ProcessResults
#' to generate the graph. The graph generated by this function is undirected and
#' is an igraph object.
#' @param inputResults A list of IntLimResults objects. Each object must include
#'  model and processing results (output of ProcessResults()).
#' @param inputData MultiDataSet object (output of ReadData()) with gene expression,
#' metabolite abundances, and associated meta-data
#' @export
BuildCoRegulationGraph <- function(inputResults, inputData){
  
  # Build each data frame.
  all_graph_df = lapply(inputResults, function(result){
    return(BuildGraphDataFrame(result, inputData))
  })
  all_edge_df = lapply(all_graph_df, function(df){
    return(df$edges)
  })
  all_node_df = lapply(all_graph_df, function(df){
    return(df$nodes)
  })
  
  # Combine all data frames into a single graph.
  edge_df = do.call(rbind, all_edge_df)
  node_df = do.call(rbind, all_node_df)
  node_df = node_df[!duplicated(node_df$node),]
  
  # Build and return the graph.
  final_graph = igraph::graph_from_data_frame(edge_df, directed = FALSE, 
                                      vertices = node_df)
  return(final_graph)
}

#' Construct a data frame that includes all information needed to build an igraph
#' object. This includes the names of the two co-regulated analytes, whether the
#' analytes have a positive or negative co-regulation, and the shape of the analytes.
#' @param inputResults A list of IntLimResults objects. Each object must include
#'  model and processing results (output of ProcessResults()).
#' @param inputData MultiDataSet object (output of ReadData()) with gene expression,
#' metabolite abundances, and associated meta-data
BuildGraphDataFrame <- function(inputResults, inputData){
  
  # Add the analytes to the data frame.
  edge_df = data.frame(from = inputResults@filt.results[,1], 
                        to = inputResults@filt.results[,2])
  
  # Add the weights and corresponding colors.
  edge_df$weight = 1
  edge_df$weight[which(inputResults@filt.results$interaction_coeff < 0)] = -1
  edge_df$color = "blue"
  edge_df$color[which(inputResults@filt.results$interaction_coeff < 0)] = "red"
  
  # Build the vertex graph, including the shape of each vertex.
  node_df_c1 = data.frame(node = unique(inputResults@filt.results[,1]), 
                          shape = "square")
  if(inputResults@independent.var.type == "metabolite"){
    node_df_c1$shape = "circle"
  }
  node_df_c2 = data.frame(node = unique(setdiff(inputResults@filt.results[,2], 
                                                inputResults@filt.results[,1])), 
                          shape = "square")
  if(inputResults@outcome == "metabolite"){
    node_df_c2$shape = "circle"
  }
  node_df = rbind(node_df_c1, node_df_c2)
  node_df$size = 5
  
  # Return the data frame.
  return(list(edges = edge_df, nodes = node_df))
}

#' Return each analyte in the graph ranked by hub score. The analytes at the top
#' of the data frame are the hubs. 
#' @param coRegulationGraph An igraph object. This graph is the co-regulation graph
#' generated using IntLIM analysis of analyte pairs.
#' @param hubMetric Can take one of four values:
#' 1. "betweenness": the betweenness centrality (i.e. the percent of all paths in the
#' graph that pass through a node).
#' 2. "kleinberg": the square of the adjacency matrix. This measures the connectivity
#' of the node.
#' 3. "closeness": the average shortest path from a node to all other nodes.
#' 4. "eccentricity": the maximum distance from a node to all other nodes.
#' @export
ComputeCentrality <- function(coRegulationGraph, hubMetric){
  centrality = data.frame(Analyte = sort(igraph::as_ids(igraph::V(coRegulationGraph))))
  if("betweenness" %in% hubMetric){
    btwn <- igraph::betweenness(coRegulationGraph, 
                                   weights = rep(1:length(igraph::E(coRegulationGraph))))
    centrality$Betweenness <- btwn[order(names(btwn))]
  }
  if("kleinberg" %in% hubMetric){
    klein <- igraph::hub.score(coRegulationGraph,
                            weights = rep(1:length(igraph::E(coRegulationGraph))))$vector
    centrality$Kleinberg <- klein[order(names(klein))]
  }
  if("closeness" %in% hubMetric){
    close <- igraph::estimate_closeness(coRegulationGraph, cutoff = 0,
                                          weights = rep(1:length(igraph::E(coRegulationGraph))))
    centrality$Closeness <- close[order(names(close))]
  }
  if("eccentricity" %in% hubMetric){
    ecc <- igraph::eccentricity(coRegulationGraph)
    centrality$Eccentricity <- ecc[order(names(ecc))]
  }
  extras <- setdiff(hubMetric, list("betweenness", "kleinberg", "closeness", 
                                    "eccentricity"))
  if(length(extras) > 0){
    print("The following are not accepted centrality metrics:")
    print(extras)
  }
  if(length(centrality) == 0){
    stop("No valid centrality metrics provided.")
  }
  rownames(centrality) = centrality$Analyte
  centrality$Analyte = NULL
  return(centrality)
}